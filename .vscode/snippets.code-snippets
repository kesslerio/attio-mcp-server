{
  // MCP Tool Handler Snippets
  "MCP Tool Handler": {
    "prefix": "mcp-handler",
    "body": [
      "import { z } from 'zod';",
      "import { ToolHandler } from '../types/tool-types.js';",
      "import { createSuccessResult, createErrorResult } from '../utils/response-formatter.js';",
      "",
      "const ${1:toolName}Schema = z.object({",
      "  ${2:// Define your schema here}",
      "});",
      "",
      "export const ${1:toolName}Handler: ToolHandler = {",
      "  name: '${3:tool-name}',",
      "  description: '${4:Tool description}',",
      "  inputSchema: ${1:toolName}Schema,",
      "  handler: async (args, apiClient) => {",
      "    try {",
      "      const validated = ${1:toolName}Schema.parse(args);",
      "      ",
      "      // Implementation here",
      "      ${0}",
      "      ",
      "      return createSuccessResult({",
      "        // Return data",
      "      });",
      "    } catch (error) {",
      "      return createErrorResult(error);",
      "    }",
      "  }",
      "};"
    ],
    "description": "Create a new MCP tool handler"
  },
  
  "Universal Tool Handler": {
    "prefix": "universal-handler",
    "body": [
      "export async function ${1:handlerName}(",
      "  args: UniversalToolArguments,",
      "  apiClient: AttioAPIClient",
      "): Promise<McpToolResponse> {",
      "  try {",
      "    const { resource_type, ${2:other_args} } = args;",
      "    ",
      "    // Validate resource type",
      "    const resourceConfig = RESOURCE_CONFIGS[resource_type];",
      "    if (!resourceConfig) {",
      "      return createErrorResult(",
      "        new Error(`Unsupported resource type: \\${resource_type}`)",
      "      );",
      "    }",
      "    ",
      "    ${0}",
      "    ",
      "    return createSuccessResult({",
      "      resource_type,",
      "      // Return data",
      "    });",
      "  } catch (error) {",
      "    return createErrorResult(error);",
      "  }",
      "}"
    ],
    "description": "Create a universal tool handler function"
  },
  
  "Vitest Test Suite": {
    "prefix": "vitest-suite",
    "body": [
      "import { describe, it, expect, beforeEach, vi } from 'vitest';",
      "import { ${1:ModuleName} } from '${2:../src/module.js}';",
      "",
      "describe('${1:ModuleName}', () => {",
      "  beforeEach(() => {",
      "    vi.clearAllMocks();",
      "  });",
      "",
      "  describe('${3:functionality}', () => {",
      "    it('should ${4:do something}', () => {",
      "      // Arrange",
      "      ${5}",
      "      ",
      "      // Act",
      "      ",
      "      // Assert",
      "      expect(${0}).toBe();",
      "    });",
      "  });",
      "});"
    ],
    "description": "Create a Vitest test suite"
  },
  
  "Vitest Integration Test": {
    "prefix": "vitest-integration",
    "body": [
      "import { describe, it, expect, beforeAll, afterAll } from 'vitest';",
      "import { createTestApiClient } from '../helpers/integration-test-setup.js';",
      "import { ${1:handler} } from '${2:../../src/handlers/}';",
      "",
      "describe('${3:Handler} Integration Tests', () => {",
      "  let apiClient: AttioAPIClient;",
      "  ",
      "  beforeAll(async () => {",
      "    apiClient = await createTestApiClient();",
      "  });",
      "  ",
      "  afterAll(async () => {",
      "    // Cleanup if needed",
      "  });",
      "  ",
      "  it('should ${4:perform operation}', async () => {",
      "    // Arrange",
      "    const args = {",
      "      ${5}",
      "    };",
      "    ",
      "    // Act",
      "    const result = await ${1:handler}(args, apiClient);",
      "    ",
      "    // Assert",
      "    expect(result.success).toBe(true);",
      "    expect(result.data).toMatchObject({",
      "      ${0}",
      "    });",
      "  });",
      "});"
    ],
    "description": "Create a Vitest integration test"
  },
  
  "API Error Handler": {
    "prefix": "api-error",
    "body": [
      "try {",
      "  ${1:// API call}",
      "} catch (error) {",
      "  if (error instanceof ApiError) {",
      "    return createErrorResult(",
      "      error,",
      "      {",
      "        statusCode: error.statusCode,",
      "        apiError: error.apiError,",
      "        context: {",
      "          operation: '${2:operation}',",
      "          ${3:// Additional context}",
      "        }",
      "      }",
      "    );",
      "  }",
      "  return createErrorResult(error);",
      "}"
    ],
    "description": "API error handling block"
  },
  
  "TypeScript Interface": {
    "prefix": "ts-interface",
    "body": [
      "export interface ${1:InterfaceName} {",
      "  ${2:property}: ${3:type};",
      "  ${0}",
      "}"
    ],
    "description": "Create a TypeScript interface"
  },
  
  "TypeScript Type": {
    "prefix": "ts-type",
    "body": [
      "export type ${1:TypeName} = {",
      "  ${2:property}: ${3:type};",
      "  ${0}",
      "};"
    ],
    "description": "Create a TypeScript type"
  },
  
  "Zod Schema": {
    "prefix": "zod-schema",
    "body": [
      "const ${1:schemaName} = z.object({",
      "  ${2:field}: z.${3:string}(),",
      "  ${0}",
      "});",
      "",
      "export type ${1/(.*)/${1:/capitalize}/} = z.infer<typeof ${1:schemaName}>;"
    ],
    "description": "Create a Zod schema with TypeScript type"
  },
  
  "Filter Builder": {
    "prefix": "filter-builder",
    "body": [
      "const filter = buildFilter({",
      "  attribute: '${1:attribute_name}',",
      "  operator: '${2|equals,not_equals,contains,not_contains,is_empty,is_not_empty|}',",
      "  value: ${3:value}",
      "});"
    ],
    "description": "Create a filter using the filter builder"
  },
  
  "Attribute Mapping": {
    "prefix": "attr-mapping",
    "body": [
      "'${1:apiField}': {",
      "  attioField: '${2:attio_field_id}',",
      "  type: '${3|text,number,date,select,multiselect,boolean|}',",
      "  transform: (value) => {",
      "    ${4:// Transform logic}",
      "    return value;",
      "  }",
      "}"
    ],
    "description": "Define an attribute mapping"
  },
  
  "Console Log Debug": {
    "prefix": "clog",
    "body": [
      "console.log('${1:label}:', JSON.stringify(${2:variable}, null, 2));"
    ],
    "description": "Console log with JSON stringification"
  },
  
  "TODO Comment": {
    "prefix": "todo",
    "body": [
      "// TODO: ${1:description} - ${2:@$USER} - ${3:$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE}"
    ],
    "description": "Add a TODO comment with author and date"
  },
  
  "RULE Comment": {
    "prefix": "rule",
    "body": [
      "// RULE: ${1:rule_name} | WHEN: ${2:condition} | DO: ${3:action} | ELSE: ${4:consequence}"
    ],
    "description": "Add a RULE comment following CLAUDE.md format"
  },
  
  "MCP Schema Validation": {
    "prefix": "mcp-validate",
    "body": [
      "// MCP SCHEMA CONSTRAINT: No complex schemas at root level",
      "// Avoid oneOf, allOf, anyOf at top level - use runtime validation instead",
      "const schema = z.object({",
      "  ${1:// Simple schema properties only}",
      "});",
      "",
      "// Runtime validation for complex constraints",
      "if (${2:condition}) {",
      "  throw new Error('${3:Validation error message}');",
      "}"
    ],
    "description": "MCP schema with validation constraints"
  },
  
  "Export Module": {
    "prefix": "export-module",
    "body": [
      "export {",
      "  ${1:exportName}",
      "} from './${2:module}.js';",
      "",
      "export type {",
      "  ${3:TypeName}",
      "} from './${2:module}.js';"
    ],
    "description": "Export module with types"
  }
}