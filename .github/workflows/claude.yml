name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

# Prevent concurrent runs for the same PR or review thread
concurrency:
  group: claude-user-review-${{ github.event_name }}-${{ github.event.pull_request.number || github.event.issue.number }}-${{ github.event.comment.id || github.event.review.id || github.run_id }}
  cancel-in-progress: false

jobs:
  claude:
    # Only run for PR contexts where someone tagged @claude
    if: |
      (
        github.event_name == 'issue_comment' &&
        github.event.issue.pull_request &&
        contains(github.event.comment.body, '@claude')
      ) || (
        github.event_name == 'pull_request_review_comment' &&
        contains(github.event.comment.body, '@claude')
      ) || (
        github.event_name == 'pull_request_review' &&
        github.event.review.body &&
        contains(github.event.review.body, '@claude')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      # Keep this job minimally privileged; do NOT grant repo write unless needed for comments.
      contents: read
      pull-requests: write      # needed to post PR comments
      issues: write             # needed to post on PR issue thread
      actions: read
      checks: read
      id-token: write           # safe to keep; action may use OIDC

    steps:
      - name: Baseline checkout (no PR code yet)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Gather PR info safely via API
      - name: Get PR info
        id: prinfo
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = (context.payload.pull_request?.number) || context.issue.number;
            if (!prNumber) { core.setFailed('No PR number found on this event.'); return; }
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            core.setOutput('number', pr.number);
            core.setOutput('head_sha', pr.head.sha);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('head_repo_full', pr.head.repo.full_name);
            core.setOutput('is_internal', String(pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`));
            core.setOutput('actor_assoc', context.payload.comment?.author_association || context.payload.review?.author_association || context.actor_association || 'NONE');

      # Detect keywords
      - name: Detect modes (ultra / ok-to-test)
        id: detect
        run: |
          TEXT="$(jq -r '.comment.body // .review.body // ""' "$GITHUB_EVENT_PATH")"
          LCTEXT="$(printf '%s' "$TEXT" | tr '[:upper:]' '[:lower:]')"
          if echo "$LCTEXT" | grep -q -E '\bultra( review)?\b'; then
            echo "ultra=true" >> "$GITHUB_OUTPUT"
          else
            echo "ultra=false" >> "$GITHUB_OUTPUT"
          fi
          if echo "$LCTEXT" | grep -q -E '\bok-?to-?test\b'; then
            echo "ok_to_test=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok_to_test=false" >> "$GITHUB_OUTPUT"
          fi

      # SECURITY GATE:
      # Only treat the PR HEAD as trusted if:
      #   - it's INTERNAL (same repo), OR
      #   - a trusted actor (OWNER/MEMBER/COLLABORATOR) has said "ok-to-test" in the triggering comment.
      - name: Compute trust
        id: trust
        run: |
          is_internal="${{ steps.prinfo.outputs.is_internal }}"
          assoc="${{ steps.prinfo.outputs.actor_assoc }}"
          ok_to_test="${{ steps.detect.outputs.ok_to_test }}"
          trusted="false"
          if [ "$is_internal" = "true" ]; then
            trusted="true"
          elif [ "$ok_to_test" = "true" ] && { [ "$assoc" = "OWNER" ] || [ "$assoc" = "MEMBER" ] || [ "$assoc" = "COLLABORATOR" ]; }; then
            trusted="true"
          fi
          echo "trusted=$trusted" >> "$GITHUB_OUTPUT"

      # If trusted, we can safely checkout PR HEAD for richer local analysis
      - name: Checkout PR HEAD (trusted only)
        if: steps.trust.outputs.trusted == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.prinfo.outputs.head_sha }}
          fetch-depth: 0

      # Trusted path → full toolset (you can drop Bash here too if you want to be extra strict)
      - name: Claude Review (trusted tree)
        id: claude_trusted
        if: steps.trust.outputs.trusted == 'true'
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ github.token }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          track_progress: true
          claude_args: >-
            --model ${{ steps.detect.outputs.ultra == 'true' && 'claude-opus-4-1-20250805' || 'claude-sonnet-4-20250514' }}
            --max-turns ${{ steps.detect.outputs.ultra == 'true' && '22' || '16' }}
            --allowed-tools Read,Glob,Grep,Bash,NotebookEdit
            --output-format stream-json
          prompt: |
            You are reviewing this PR with full working tree available.
            Enforce:
            - SRP; size limits (fn ≤ 30–40; classes/files ≤ 500; ≤ 20–30 methods/class)
            - Refactor in small, tested steps; don't mix with bugfixes; dedupe first
            - TS style: prefer Record<string, unknown>; PascalCase/camelCase; ordered imports; no unused
            - Commits: conventional or repo override; keep #issue linkage
            Output Markdown with: Summary • Top findings • Suggested tests • Quick refactors • Risk level.
            If "ultra" mode, add deep security/perf/architecture analysis and minimal corrective diffs.

      # UNTRUSTED path → API-only analysis (NO checkout of PR head, NO shell)
      - name: Claude Review (untrusted, API-only)
        id: claude_untrusted
        if: steps.trust.outputs.trusted != 'true'
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ github.token }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          track_progress: true
          # No Bash; only safe read/glob/grep operations inside the action's sandbox
          claude_args: >-
            --model ${{ steps.detect.outputs.ultra == 'true' && 'claude-opus-4-1-20250805' || 'claude-sonnet-4-20250514' }}
            --max-turns ${{ steps.detect.outputs.ultra == 'true' && '22' || '16' }}
            --allowed-tools Read,Glob,Grep
            --output-format stream-json
          prompt: |
            You are reviewing this PR WITHOUT checking out its code (untrusted context).
            Use GitHub API metadata and diffs to analyze changes. Do NOT execute any PR code.
            Enforce the same standards:
            - SRP; size limits (fn ≤ 30–40; classes/files ≤ 500; ≤ 20–30 methods/class)
            - Refactor in small, tested steps; no mixing refactors with fixes; dedupe first
            - TS style: prefer Record<string, unknown>; PascalCase/camelCase; ordered imports; no unused
            - Commits: conventional or repo override; keep #issue linkage
            Output Markdown with: Summary • Top findings • Suggested tests • Quick refactors • Risk level.
            If "ultra" mode, include deeper architecture/security/performance critique.
            If the review is limited due to API-only context, clearly state the limitation and what extra checks you'd perform with a trusted checkout.

      # Fallback: if for any reason the action didn't post a comment, synthesize one from outputs
      - name: Ensure review is posted (fallback)
        if: always()
        uses: actions/github-script@v7
        env:
          EXEC_FILE_TRUSTED: ${{ steps.claude_trusted.outputs.execution_file }}
          EXEC_FILE_UNTRUSTED: ${{ steps.claude_untrusted.outputs.execution_file }}
          RESULT_TRUSTED: ${{ steps.claude_trusted.outputs.result }}
          RESULT_UNTRUSTED: ${{ steps.claude_untrusted.outputs.result }}
        with:
          script: |
            const fs = require('fs');
            const execFile = process.env.EXEC_FILE_TRUSTED || process.env.EXEC_FILE_UNTRUSTED;
            let body = (process.env.RESULT_TRUSTED || process.env.RESULT_UNTRUSTED || '').trim();

            // Avoid duplicate comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 50
            });
            if (comments.some(c =>
              /Overall Risk:|Top Findings:|Suggested tests|Quick refactors/i.test(c.body || '') &&
              c.user?.type === 'Bot'
            )) {
              core.info('A Claude review comment already exists; skipping fallback.');
              return;
            }

            if (!body && execFile && fs.existsSync(execFile)) {
              try {
                const data = JSON.parse(fs.readFileSync(execFile, 'utf8'));
                if (typeof data.result === 'string' && data.result.trim()) body = data.result.trim();
                else if (Array.isArray(data.turns)) {
                  for (let i = data.turns.length - 1; i >= 0; i--) {
                    const m = data.turns[i]?.message;
                    const parts = Array.isArray(m?.content) ? m.content : [];
                    const text = parts.filter(p => p.type === 'text').map(p => p.text).join('\n').trim();
                    if (text) { body = text; break; }
                  }
                }
              } catch (e) {
                core.warning('Could not parse execution_file JSON.');
              }
            }
            if (!body) body = '_Claude produced a review, but no formatted output was found. Check the workflow logs._';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
            core.info('Posted fallback review comment.');
