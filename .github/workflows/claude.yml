name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

# Prevent concurrent runs for the same PR or review thread
concurrency:
  group: claude-user-review-${{ github.event_name }}-${{ github.event.pull_request.number || github.event.issue.number }}-${{ github.event.comment.id || github.event.review.id || github.run_id }}
  cancel-in-progress: false

jobs:
  claude:
    # Only run for PR contexts where someone actually tagged @claude
    if: |
      (
        github.event_name == 'issue_comment' &&
        github.event.issue.pull_request &&
        contains(github.event.comment.body, '@claude')
      ) || (
        github.event_name == 'pull_request_review_comment' &&
        contains(github.event.comment.body, '@claude')
      ) || (
        github.event_name == 'pull_request_review' &&
        github.event.review.body &&
        contains(github.event.review.body, '@claude')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      id-token: write         # for OIDC if used by the action
      contents: read          # review-only: no file writes needed
      pull-requests: write    # allow posting PR comments
      issues: write           # allow posting on PR issue thread
      actions: read           # allow reading CI status
      checks: read

    steps:
      # Initial checkout (safe default); we'll replace the tree with PR head in a moment.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Ensure we analyze the PR head, so files exist locally before Claude runs.
      - name: Get PR info from comment/review context
        if: |
          github.event_name == 'issue_comment' ||
          github.event_name == 'pull_request_review_comment' ||
          github.event_name == 'pull_request_review'
        id: prinfo
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = (context.payload.pull_request?.number) || context.issue.number;
            if (!prNumber) {
              core.setFailed('No PR number found on this event.');
              return;
            }
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            core.setOutput('number', pr.number);
            core.setOutput('head_sha', pr.head.sha);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('repo_full', pr.head.repo.full_name);

      - name: Checkout PR head (ensures files exist before Claude runs)
        if: steps.prinfo.outputs.head_sha != ''
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.prinfo.outputs.head_sha }}
          fetch-depth: 0

      # Case-insensitive "ultra" detector for Opus mode
      - name: Detect ultra keyword
        id: detect
        run: |
          TEXT="$(jq -r '.comment.body // .review.body // ""' "$GITHUB_EVENT_PATH")"
          LCTEXT="$(printf '%s' "$TEXT" | tr '[:upper:]' '[:lower:]')"
          if echo "$LCTEXT" | grep -q -E '\bultra( review)?\b'; then
            echo "ultra=true" >> "$GITHUB_OUTPUT"
          else
            echo "ultra=false" >> "$GITHUB_OUTPUT"
          fi

      # === Opus 4.1: deep/critical review – only when explicitly requested ===
      - name: Claude Review (Opus – ultra)
        id: claude_opus
        if: steps.detect.outputs.ultra == 'true'
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ github.token }}         # authenticate gh / GitHub API
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}     # let the action post/update comments
          track_progress: true                  # maintain a single tracking comment
          claude_args: >-
            --model claude-opus-4-1-20250805
            --max-turns 22
            --allowed-tools Read,Glob,Grep,Bash,NotebookEdit
            --output-format stream-json
          prompt: |
            You are performing a DEEP CRITICAL PR review for the current pull request.
            Prioritize correctness, security, performance, robustness, and maintainability.
            Treat this as a critical/complex change that may impact production.

            ## Scope & Deliverables
            1) Summary of the change and likely intent.
            2) Critical issues with code examples (bugs, security, concurrency/race, perf hotspots, error-handling).
            3) Test plan: concrete missing test cases (filenames + test names), suggest input matrices/edge cases.
            4) Architecture/Design review: layering, hidden coupling, SRP adherence, refactor opportunities.
            5) Minimal, actionable patches: propose exact diffs or code blocks for the most important fixes.
            6) Risk assessment: High/Medium/Low, with rationale and rollback/mitigation notes.

            ## Code Quality Standards (ENFORCE)
            - Single Responsibility Principle (SRP)
            - Size limits: functions ≤ 30–40 lines; classes/files ≤ 500 lines; ≤ 20–30 methods/class
            - Refactoring best practices: small steps; don't mix with bugfixes; dedupe first; add focused tests
            - Universal standards:
              * TypeScript: prefer Record<string, unknown> over any; PascalCase for classes/interfaces; camelCase for vars/functions
              * Errors: explicit handling; no swallowed failures
              * Imports: node → external → internal; remove unused
              * Commits: conventional or repo override; retain #issue linkage

            ## Output (Markdown)
            - **Overall Risk:** (High/Medium/Low) + brief rationale
            - **Top Findings:** bullets with snippet/diff when helpful
            - **Tests to Add:** file + test name + brief intent
            - **Refactors:** incremental steps aligned with SRP/size limits
            - **Perf/Sec Notes:** explicit callouts with quick wins

      # === Sonnet: fast 80/20 review – default ===
      - name: Claude Review (Sonnet – solo-dev 80/20)
        id: claude_sonnet
        if: steps.detect.outputs.ultra != 'true'
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ github.token }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          track_progress: true
          claude_args: >-
            --model claude-sonnet-4-20250514
            --max-turns 16
            --allowed-tools Read,Glob,Grep,Bash,NotebookEdit
            --output-format stream-json
          prompt: |
            You are reviewing a PR for a solo maintainer of the attio-mcp-server repo.
            Be pragmatic and time-aware: prioritize the highest-impact fixes and clarity.
            Strictly check:
              - Correctness & regressions
              - Security (input validation, secrets, auth, error messages)
              - Performance red flags
              - Maintainability & readability
              - The standards listed below
            Keep suggestions scoped and actionable; prefer small diffs over broad rewrites.

            ## Code Quality Standards (ENFORCE)
            - SRP; size limits (fn ≤ 30–40 lines; classes/files ≤ 500; ≤ 20–30 methods/class)
            - Refactor in small steps; don't mix refactors with fixes; dedupe first
            - TS style: Record<string, unknown> over any; PascalCase/camelCase; ordered imports; no unused
            - Commits: conventional or repo override; keep #issue linkage

            ## Output (Markdown)
            - **Summary**
            - **Top 5 Issues** (with short code refs)
            - **Suggested Tests**
            - **Quick Refactors**
            - **Risk Level** (and why)

      # === Fallback: if no comment was created for any reason, post one ===
      - name: Ensure review is posted (fallback)
        if: always()
        uses: actions/github-script@v7
        env:
          EXEC_FILE_OPUS: ${{ steps.claude_opus.outputs.execution_file }}
          EXEC_FILE_SONNET: ${{ steps.claude_sonnet.outputs.execution_file }}
          RESULT_OPUS: ${{ steps.claude_opus.outputs.result }}
          RESULT_SONNET: ${{ steps.claude_sonnet.outputs.result }}
        with:
          script: |
            const fs = require('fs');

            const result = (process.env.RESULT_OPUS || process.env.RESULT_SONNET || '').trim();
            const execFile = process.env.EXEC_FILE_OPUS || process.env.EXEC_FILE_SONNET;

            // Avoid duplicate bot comments if one already exists
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 50
            });
            if (comments.some(c =>
              /Overall Risk:|Top Findings:|Security|Tests to Add/i.test(c.body || '') &&
              c.user?.type === 'Bot'
            )) {
              core.info('A Claude review comment already exists; skipping fallback.');
              return;
            }

            let body = result;
            if (!body && execFile && fs.existsSync(execFile)) {
              try {
                const data = JSON.parse(fs.readFileSync(execFile, 'utf8'));
                if (typeof data.result === 'string' && data.result.trim()) {
                  body = data.result.trim();
                } else if (Array.isArray(data.turns)) {
                  for (let i = data.turns.length - 1; i >= 0; i--) {
                    const m = data.turns[i]?.message;
                    const parts = Array.isArray(m?.content) ? m.content : [];
                    const text = parts.filter(p => p.type === 'text').map(p => p.text).join('\n').trim();
                    if (text) { body = text; break; }
                  }
                }
              } catch (e) {
                core.warning('Could not parse execution_file JSON.');
              }
            }

            if (!body) {
              body = '_Claude produced a review, but no formatted output was found. Check the workflow logs._';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
            core.info('Posted fallback review comment.');
