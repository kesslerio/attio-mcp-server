name: Claude PR Review (labeled)

on:
  workflow_dispatch:
    inputs:
      pr:
        description: 'PR number'
        required: true
      label:
        description: 'claude:review or claude:ultra'
        required: true
      source:
        description: 'Dispatch source for debugging'
        required: false
        default: 'gate'
  pull_request:
    types: [reopened] # optional: manual nudge path for reopened PRs

concurrency:
  group: claude-pr-labeled-${{ github.event.inputs.pr || github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read
  checks: read

jobs:
  review:
    # Run for workflow_dispatch or PR reopened (with Claude label)
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'pull_request' && github.event.action == 'reopened' &&
       (contains(github.event.pull_request.labels.*.name, 'claude:review') ||
        contains(github.event.pull_request.labels.*.name, 'claude:ultra')))

    runs-on: ubuntu-latest

    concurrency:
      group: pr-${{ github.event.inputs.pr || github.event.pull_request.number }}-claude-review
      cancel-in-progress: true

    steps:
      - name: Resolve inputs
        id: resolve
        run: |
          echo "pr=${{ github.event.inputs.pr || github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "label=${{ github.event.inputs.label || 'claude:review' }}" >> $GITHUB_OUTPUT
          echo "source=${{ github.event.inputs.source || 'reopened' }}" >> $GITHUB_OUTPUT
          echo "ðŸ” Dispatch source: ${{ github.event.inputs.source || 'reopened' }}"

      # Fast label check to short-circuit unrelated label churn
      - name: Has claude label?
        id: haslabel
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.resolve.outputs.pr }}';
            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, per_page: 100
            });
            const names = new Set(labels.map(l => l.name));
            const hasReview = names.has('claude:review');
            const hasUltra  = names.has('claude:ultra');
            core.setOutput('has', String(hasReview || hasUltra));
            core.setOutput('has_review', String(hasReview));
            core.setOutput('has_ultra',  String(hasUltra));

      - name: Skip if not a Claude label
        if: steps.haslabel.outputs.has != 'true' && github.event_name == 'pull_request'
        run: exit 0

      # Optional (audit egress): set to "audit" first; switch to "block" once stable
      - name: Harden Runner (egress audit)
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Get PR info & determine environment
        id: decide
        if: steps.haslabel.outputs.has == 'true' || (github.event_name == 'pull_request' && github.event.action == 'reopened') || github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            // Get PR number from resolved inputs
            const prNumber = '${{ steps.resolve.outputs.pr }}';
            if (!prNumber) {
              core.setFailed('No PR number resolved'); return;
            }

            // Always fetch the PR fresh
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const internal = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;
            const changed = pr.changed_files || 0;
            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalLines = additions + deletions;

            // Optional debug (shows up in logs)
            core.info(`PR #${pr.number}: internal=${internal}, changed=${changed} files, lines=${totalLines}`);

            core.setOutput('internal', String(internal));
            core.setOutput('pr', String(pr.number));
            core.setOutput('sha', pr.head.sha);
            core.setOutput('changed', String(changed));
            core.setOutput('lines', String(totalLines));

      - name: Calculate turn limits based on PR size
        id: turns
        run: |
          lines=${{ steps.decide.outputs.lines || 0 }}
          files=${{ steps.decide.outputs.changed || 0 }}

          # Scale turns with diff size (bigger diff â†’ more turns)
          if   [ $lines -le 400  ]; then sonnet_cap=22; opus_cap=26
          elif [ $lines -le 1500 ]; then sonnet_cap=32; opus_cap=38
          elif [ $lines -le 4000 ]; then sonnet_cap=44; opus_cap=52
          else                         sonnet_cap=56; opus_cap=64
          fi

          # Calculate cutoff turns (when to stop using tools)
          sonnet_cutoff=$((sonnet_cap - 6))
          opus_cutoff=$((opus_cap - 8))

          echo "sonnet_turns=$sonnet_cap" >> $GITHUB_OUTPUT
          echo "opus_turns=$opus_cap" >> $GITHUB_OUTPUT
          echo "sonnet_cutoff=$sonnet_cutoff" >> $GITHUB_OUTPUT
          echo "opus_cutoff=$opus_cutoff" >> $GITHUB_OUTPUT

          # Summary for maintainers in both logs and step summary
          summary="ðŸŽ¯ PR size: $lines lines, $files files â†’ Sonnet: $sonnet_cap turns, Opus: $opus_cap turns"
          echo "$summary"
          echo "$summary" >> $GITHUB_STEP_SUMMARY

      # Fork PRs won't have repo secrets -> comment guidance and skip
      - name: Handle forks (no secrets in PR context)
        if: steps.decide.outputs.internal != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.decide.outputs.pr }}');
            const body =
              `ðŸ”’ This is a fork PR. For security, secrets are not available in PR jobs.\n\n` +
              `To run Claude reviews with full checkout, use **Actions â†’ Claude Trusted Review (manual)** on PR #${prNumber}, or approve a maintainer-run workflow.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body
            });

      - name: Exit on forks
        if: steps.decide.outputs.internal != 'true'
        run: exit 0

      - name: Checkout PR HEAD
        if: steps.decide.outputs.internal == 'true' && (steps.haslabel.outputs.has == 'true' || github.event_name == 'workflow_dispatch')
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.decide.outputs.sha }}
          fetch-depth: 0
          persist-credentials: false # defensive; we're not pushing

      - name: Claude Review (Sonnet)
        if: steps.decide.outputs.internal == 'true' && (steps.haslabel.outputs.has_review == 'true' || (github.event_name == 'workflow_dispatch' && steps.resolve.outputs.label == 'claude:review'))
        id: claude_sonnet
        timeout-minutes: 12
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          claude_args: >-
            --model claude-sonnet-4-20250514
            --max-turns ${{ steps.turns.outputs.sonnet_turns }}
            --allowed-tools Read,Glob,Grep,NotebookEdit
            --output-format stream-json
          prompt: |
            IMPORTANT EXECUTION RULES
            - Do NOT run `npm install` or add dependencies; if tests/lint aren't available, skip them.
            - By turn ${{ steps.turns.outputs.sonnet_cutoff }}, STOP using tools and write the final Markdown report.
            - Always emit a single final report with sections:
              Summary â€¢ Top Findings â€¢ Suggested Tests â€¢ Quick Refactors â€¢ Perf/Sec Notes â€¢ Risk Level
            - End the report with the exact marker: END-OF-REPORT

            Perform a PR review with full working tree access.

            Enforce:
            ## Code Quality Standards
            ### Single Responsibility Principle (SRP)
            - One class/module â†’ one reason to change. Detect mixed concerns, many dependencies, multiple change reasons.

            ### Size Limits & Refactoring Triggers
            - Functions: â‰¤30â€“40 lines; Classes/Files: â‰¤500 lines; Methods per class: â‰¤20â€“30.
            - Trigger refactor on complexity or mixed concerns.

            ### Refactoring Best Practices
            - Small steps; test each change. Don't mix refactors with bug fixes.
            - Deduplicate first; add focused tests.

            ### Universal Coding Standards
            - TypeScript: prefer Record<string, unknown> over any
            - PascalCase (classes/interfaces), camelCase (functions/variables)
            - Imports: node â†’ external â†’ internal; remove unused
            - Commits: conventional or repo override; keep #issue linkage

            Output Markdown:
            - **Summary**
            - **Top Findings** (with code snippets/diffs)
            - **Suggested Tests** (file + test name)
            - **Quick Refactors** (incremental, SRP-aligned)
            - **Perf/Sec Notes** (explicit quick wins)
            - **Risk Level** with rationale

      - name: Claude Review (Opus)
        if: steps.decide.outputs.internal == 'true' && (steps.haslabel.outputs.has_ultra == 'true' || (github.event_name == 'workflow_dispatch' && steps.resolve.outputs.label == 'claude:ultra'))
        id: claude_opus
        timeout-minutes: 15
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          claude_args: >-
            --model claude-opus-4-1-20250805
            --max-turns ${{ steps.turns.outputs.opus_turns }}
            --allowed-tools Read,Glob,Grep,NotebookEdit
            --output-format stream-json
          prompt: |
            IMPORTANT EXECUTION RULES
            - Do NOT run `npm install` or add dependencies; if tests/lint aren't available, skip them.
            - By turn ${{ steps.turns.outputs.opus_cutoff }}, STOP using tools and write the final Markdown report.
            - Always emit a single final report with sections:
              Summary â€¢ Top Findings â€¢ Suggested Tests â€¢ Quick Refactors â€¢ Perf/Sec Notes â€¢ Risk Level
            - End the report with the exact marker: END-OF-REPORT

            Perform a PR review with full working tree access.

            Enforce:
            ## Code Quality Standards
            ### Single Responsibility Principle (SRP)
            - One class/module â†’ one reason to change. Detect mixed concerns, many dependencies, multiple change reasons.

            ### Size Limits & Refactoring Triggers
            - Functions: â‰¤30â€“40 lines; Classes/Files: â‰¤500 lines; Methods per class: â‰¤20â€“30.
            - Trigger refactor on complexity or mixed concerns.

            ### Refactoring Best Practices
            - Small steps; test each change. Don't mix refactors with bug fixes.
            - Deduplicate first; add focused tests.

            ### Universal Coding Standards
            - TypeScript: prefer Record<string, unknown> over any
            - PascalCase (classes/interfaces), camelCase (functions/variables)
            - Imports: node â†’ external â†’ internal; remove unused
            - Commits: conventional or repo override; keep #issue linkage

            Output Markdown:
            - **Summary**
            - **Top Findings** (with code snippets/diffs)
            - **Suggested Tests** (file + test name)
            - **Quick Refactors** (incremental, SRP-aligned)
            - **Perf/Sec Notes** (explicit quick wins)
            - **Risk Level** with rationale

            If mode is **ultra**, go deeper on security, performance, concurrency, error-handling, and propose minimal diffs.

      - name: Capture Sonnet Review Output
        if: steps.claude_sonnet.outcome == 'success' && steps.claude_sonnet.outputs.execution_file != ''
        shell: bash
        run: |
          set -euo pipefail
          EXEC_FILE="${{ steps.claude_sonnet.outputs.execution_file }}"
          if [ -f "$EXEC_FILE" ]; then
            echo "ðŸ“„ Processing execution file: $EXEC_FILE"

            # 1) Try to pull ALL 'text' occurrences (covers delta.text too)
            REVIEW_CONTENT=""
            if command -v jq >/dev/null 2>&1; then
              # Process line-by-line to preserve stream order, prefer delta.text over text
              REVIEW_CONTENT="$(jq -r '
                if type=="object" then (.delta?.text? // .text // empty) else empty end
              ' "$EXEC_FILE" 2>/dev/null | tr -d "\r")" || true
            fi

            # 2) Fallback: quick-and-dirty extractor for "text":"..." pairs (NDJSON safe)
            if [ -z "$REVIEW_CONTENT" ]; then
              REVIEW_CONTENT="$(awk '
                {
                  while (match($0, /\"text\"\s*:\s*\"((\\.|[^\"])*)\"/, m)) {
                    s=m[1]; gsub(/\\n/, "\n", s); gsub(/\\"/, "\"", s); gsub(/\\\\/, "\\", s);
                    printf "%s", s;
                    $0=substr($0, RSTART+RLENGTH);
                  }
                }
              ' "$EXEC_FILE")"
            fi

            # Trim and cut at END-OF-REPORT if present
            REVIEW_CONTENT="$(printf "%s" "$REVIEW_CONTENT" | sed 's/END-OF-REPORT.*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

            if [ -n "$REVIEW_CONTENT" ]; then
              echo "âœ… Captured Sonnet review content (${#REVIEW_CONTENT} chars)"
              {
                echo "RESULT_SONNET<<EOF"
                echo "$REVIEW_CONTENT"
                echo "EOF"
              } >> "$GITHUB_ENV"
            else
              echo "âŒ No review content found in execution file (after jq/awk). Showing tail:"
              tail -n 20 "$EXEC_FILE" || true
            fi
          else
            echo "âŒ Execution file not found: $EXEC_FILE"
          fi

      - name: Capture Opus Review Output
        if: steps.claude_opus.outcome == 'success' && steps.claude_opus.outputs.execution_file != ''
        shell: bash
        run: |
          set -euo pipefail
          EXEC_FILE="${{ steps.claude_opus.outputs.execution_file }}"
          if [ -f "$EXEC_FILE" ]; then
            echo "ðŸ“„ Processing execution file: $EXEC_FILE"

            # 1) Try to pull ALL 'text' occurrences (covers delta.text too)
            REVIEW_CONTENT=""
            if command -v jq >/dev/null 2>&1; then
              # Process line-by-line to preserve stream order, prefer delta.text over text
              REVIEW_CONTENT="$(jq -r '
                if type=="object" then (.delta?.text? // .text // empty) else empty end
              ' "$EXEC_FILE" 2>/dev/null | tr -d "\r")" || true
            fi

            # 2) Fallback: quick-and-dirty extractor for "text":"..." pairs (NDJSON safe)
            if [ -z "$REVIEW_CONTENT" ]; then
              REVIEW_CONTENT="$(awk '
                {
                  while (match($0, /\"text\"\s*:\s*\"((\\.|[^\"])*)\"/, m)) {
                    s=m[1]; gsub(/\\n/, "\n", s); gsub(/\\"/, "\"", s); gsub(/\\\\/, "\\", s);
                    printf "%s", s;
                    $0=substr($0, RSTART+RLENGTH);
                  }
                }
              ' "$EXEC_FILE")"
            fi

            # Trim and cut at END-OF-REPORT if present
            REVIEW_CONTENT="$(printf "%s" "$REVIEW_CONTENT" | sed 's/END-OF-REPORT.*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

            if [ -n "$REVIEW_CONTENT" ]; then
              echo "âœ… Captured Opus review content (${#REVIEW_CONTENT} chars)"
              {
                echo "RESULT_OPUS<<EOF"
                echo "$REVIEW_CONTENT"
                echo "EOF"
              } >> "$GITHUB_ENV"
            else
              echo "âŒ No review content found in execution file (after jq/awk). Showing tail:"
              tail -n 20 "$EXEC_FILE" || true
            fi
          else
            echo "âŒ Execution file not found: $EXEC_FILE"
          fi

      - name: Debug review env
        run: |
          echo "RESULT_SONNET chars:" $(printf %s "$RESULT_SONNET" | wc -c)
          echo "RESULT_OPUS chars:" $(printf %s "$RESULT_OPUS" | wc -c)
          ls -l "${{ steps.claude_sonnet.outputs.execution_file }}" 2>/dev/null || true
          ls -l "${{ steps.claude_opus.outputs.execution_file }}" 2>/dev/null || true

      - name: Post PR review (robust)
        if: always() && steps.decide.outputs.internal == 'true' && (steps.haslabel.outputs.has == 'true' || github.event_name == 'workflow_dispatch')
        uses: actions/github-script@v7
        env:
          EXEC_FILE_SONNET: ${{ steps.claude_sonnet.outputs.execution_file }}
          EXEC_FILE_OPUS: ${{ steps.claude_opus.outputs.execution_file }}
        with:
          script: |
            const fs = require('fs');
            const LIMIT = 65000;

            // Event-agnostic PR number detection
            const prNumber = Number('${{ steps.resolve.outputs.pr }}');

            if (!prNumber) {
              core.info('No PR number found; skipping comment posting.');
              return;
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, per_page: 100
            });
            // Don't double-post if our final-style comment already exists
            const runTag = `claude-run-${context.runId}`;
            const already = comments.some(c =>
              (c.body || '').includes(runTag) ||
              (/Top Findings:|Suggested Tests|Quick Refactors|Perf\/Sec Notes|Overall Risk:/i.test(c.body || '') &&
               c.user?.type === 'Bot')
            );
            if (already) {
              core.info('Review comment already exists for this run; skipping posting.');
              return;
            }

            // Prefer the deeper Opus pass if both exist
            let body = (process.env.RESULT_OPUS || process.env.RESULT_SONNET || '').trim();

            // Robust extractor: handles delta.text, text nodes, arrays, messages, etc.
            function extractText(node, out) {
              if (!node) return;
              if (Array.isArray(node)) { node.forEach(n => extractText(n, out)); return; }
              if (typeof node === 'object') {
                // Anthropic stream deltas - prefer this over plain text
                if (node.delta && typeof node.delta.text === 'string') {
                  out.push(node.delta.text);
                  // Don't process plain text if we found delta.text to avoid duplication
                } else {
                  // Plain text nodes (only if no delta.text was found)
                  if (node.type === 'text' && typeof node.text === 'string') out.push(node.text);
                  // Generic: capture any string-valued "text" (only if no delta)
                  else if (Object.prototype.hasOwnProperty.call(node, 'text') && typeof node.text === 'string') out.push(node.text);
                }

                // Recurse into nested structures (but skip delta to avoid double-processing)
                for (const k of ['content','turns','messages','data','message']) {
                  if (node[k] !== undefined) extractText(node[k], out);
                }
                // Only recurse into delta if it doesn't have text (to avoid reprocessing delta.text)
                if (node.delta && !node.delta.text) extractText(node.delta, out);
              }
            }

            if (!body) {
              const execFile = process.env.EXEC_FILE_SONNET || process.env.EXEC_FILE_OPUS;
              if (execFile && fs.existsSync(execFile)) {
                try {
                  const raw = fs.readFileSync(execFile, 'utf8').trim();
                  const chunks = [];

                  // First try NDJSON (stream JSON)
                  for (const line of raw.split(/\r?\n/)) {
                    const s = line.trim();
                    if (!s) continue;
                    try {
                      extractText(JSON.parse(s), chunks);
                    } catch {}
                  }

                  // Fallback: single JSON blob
                  if (!chunks.length) {
                    try { extractText(JSON.parse(raw), chunks); } catch {}
                  }

                  // Join deltas without injecting extra newlines
                  body = chunks.join('').trim();

                  // Cut at the sentinel if present
                  const end = body.indexOf('END-OF-REPORT');
                  if (end !== -1) body = body.slice(0, end);
                } catch (e) {
                  core.warning(`Failed to parse execution file: ${e.message}`);
                }
              }
            }

            if (!body) {
              core.info('No review content found; skipping comment posting.');
              return; // don't post placeholders
            }

            // Clean up the END-OF-REPORT marker for final display
            body = body.replace(/END-OF-REPORT\s*$/, '').trim();

            // Chunk if needed
            const parts = [];
            for (let i = 0; i < body.length; i += LIMIT) parts.push(body.slice(i, i + LIMIT));

            for (let i = 0; i < parts.length; i++) {
              const runTag = `\n\n<!-- claude-run-${context.runId}-${i} -->`;
              const suffix = parts.length > 1 ? `\n\nâ€” part ${i+1}/${parts.length}` : '';
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
                body: parts[i] + suffix + runTag
              });
            }
            core.info(`Posted PR review comment (${parts.length} part${parts.length > 1 ? 's' : ''}).`);

      # Remove claude label after review completes to prevent auto re-runs on subsequent pushes
      - name: Remove claude label (prevents auto re-run)
        if: always() && steps.decide.outputs.internal == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.resolve.outputs.pr }}');

            // Check which label was applied by looking at completed steps
            const sonnetRan = '${{ steps.claude_sonnet.outcome }}' !== '';
            const opusRan = '${{ steps.claude_opus.outcome }}' !== '';

            const labelsToRemove = [];
            if (sonnetRan) labelsToRemove.push('claude:review');
            if (opusRan) labelsToRemove.push('claude:ultra');

            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label
                });
                core.info(`Removed ${label} label to prevent auto re-runs on future pushes.`);
              } catch (e) {
                if (e.status === 404) {
                  core.info(`Label ${label} was already removed.`);
                } else {
                  core.warning(`Failed to remove label ${label}: ${e.message}`);
                }
              }
            }
