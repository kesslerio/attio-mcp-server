name: Claude PR Review (labeled)

on:
  pull_request:
    types: [labeled, synchronize, reopened]
  issues:
    types: [labeled] # <â€” NEW: catch label events emitted via Issues API

concurrency:
  group: claude-pr-labeled-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read
  checks: read

jobs:
  review:
    # Only proceed if this is a PR (issues:labeled can also fire on pure issues)
    if: |
      (github.event_name == 'pull_request') ||
      (github.event_name == 'issues' && github.event.issue.pull_request)

    runs-on: ubuntu-latest

    steps:
      # Optional (audit egress): set to "audit" first; switch to "block" once stable
      - name: Harden Runner (egress audit)
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Decide mode & environment
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            // Get PR number regardless of event
            const prNumber = context.payload.pull_request?.number
              ?? context.payload.issue?.number;
            if (!prNumber) {
              core.setFailed('No PR number on this event'); return;
            }

            // Always fetch the PR fresh
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // ðŸ”‘ CRITICAL: fetch labels from the Issues API (source of truth)
            const { data: labelsResp } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100
            });
            const labelNames = labelsResp.map(l => l.name);

            // Include the label from payload (handles races / eventual consistency)
            const eventLabel = (context.payload.label && context.payload.label.name) || '';
            const all = new Set(labelNames.concat([eventLabel].filter(Boolean)));

            const ultra = all.has('claude:ultra');
            const normal = all.has('claude:review');
            const should_run = ultra || normal;

            const internal = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;
            const changed = pr.changed_files || 0;

            const model = ultra ? 'claude-opus-4-1-20250805' : 'claude-sonnet-4-20250514';
            let turns = ultra ? 22 : 16;
            if (changed > 60 && turns > 18) turns = 18; // soft cost cap

            // Optional debug (shows up in logs)
            core.info(`labels: ${JSON.stringify([...all])}`);
            core.info(`mode: ${ultra ? 'ultra' : (normal ? 'review' : 'none')}, internal: ${internal}, changed: ${changed}`);

            core.setOutput('should_run', String(should_run));
            core.setOutput('mode', ultra ? 'ultra' : (normal ? 'review' : 'none'));
            core.setOutput('model', model);
            core.setOutput('turns', String(turns));
            core.setOutput('internal', String(internal));
            core.setOutput('pr', String(pr.number));
            core.setOutput('sha', pr.head.sha);
            core.setOutput('labels', JSON.stringify([...all]));

      - name: Stop if no claude:* label
        if: steps.decide.outputs.should_run != 'true'
        run: echo "No claude:* label present. labels_seen=${{ steps.decide.outputs.labels || 'n/a' }} Skipping."

      # Fork PRs won't have repo secrets -> comment guidance and skip
      - name: Handle forks (no secrets in PR context)
        if: steps.decide.outputs.should_run == 'true' && steps.decide.outputs.internal != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.decide.outputs.pr }}');
            const mode = '${{ steps.decide.outputs.mode }}';
            const tag = mode === 'ultra' ? '**Opus (ultra)**' : '**Sonnet**';
            const body =
              `ðŸ”’ This is a fork PR. For security, secrets are not available in PR jobs.\n\n` +
              `To run ${tag} with full checkout, use **Actions â†’ Claude Trusted Review (manual)** on PR #${prNumber}, or approve a maintainer-run workflow.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body
            });

      - name: Exit on forks
        if: steps.decide.outputs.should_run == 'true' && steps.decide.outputs.internal != 'true'
        run: exit 0

      - name: Checkout PR HEAD
        if: steps.decide.outputs.should_run == 'true' && steps.decide.outputs.internal == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.decide.outputs.sha }}
          fetch-depth: 0

      - name: Claude Review (Sonnet)
        if: steps.decide.outputs.mode == 'review' && steps.decide.outputs.internal == 'true'
        id: claude_sonnet
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          label_trigger: 'claude:review'
          claude_args: >-
            --model claude-sonnet-4-20250514
            --max-turns 16
            --allowed-tools Read,Glob,Grep,NotebookEdit,Bash
            --output-format stream-json

      - name: Claude Review (Opus)
        if: steps.decide.outputs.mode == 'ultra' && steps.decide.outputs.internal == 'true'
        id: claude_opus
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ github.token }}
          label_trigger: 'claude:ultra'
          claude_args: >-
            --model claude-opus-4-1-20250805
            --max-turns 22
            --allowed-tools Read,Glob,Grep,NotebookEdit,Bash
            --output-format stream-json
          prompt: |
            Perform a PR review with full working tree access.

            Enforce:
            ## Code Quality Standards
            ### Single Responsibility Principle (SRP)
            - One class/module â†’ one reason to change. Detect mixed concerns, many dependencies, multiple change reasons.

            ### Size Limits & Refactoring Triggers
            - Functions: â‰¤30â€“40 lines; Classes/Files: â‰¤500 lines; Methods per class: â‰¤20â€“30.
            - Trigger refactor on complexity or mixed concerns.

            ### Refactoring Best Practices
            - Small steps; test each change. Don't mix refactors with bug fixes.
            - Deduplicate first; add focused tests.

            ### Universal Coding Standards
            - TypeScript: prefer Record<string, unknown> over any
            - PascalCase (classes/interfaces), camelCase (functions/variables)
            - Imports: node â†’ external â†’ internal; remove unused
            - Commits: conventional or repo override; keep #issue linkage

            Output Markdown:
            - **Summary**
            - **Top Findings** (with code snippets/diffs)
            - **Suggested Tests** (file + test name)
            - **Quick Refactors** (incremental, SRP-aligned)
            - **Perf/Sec Notes** (explicit quick wins)
            - **Risk Level** with rationale

            If mode is **ultra**, go deeper on security, performance, concurrency, error-handling, and propose minimal diffs.

      - name: Ensure review is posted (fallback)
        if: always() && steps.decide.outputs.should_run == 'true' && steps.decide.outputs.internal == 'true'
        uses: actions/github-script@v7
        env:
          EXEC_FILE_SONNET: ${{ steps.claude_sonnet.outputs.execution_file }}
          EXEC_FILE_OPUS: ${{ steps.claude_opus.outputs.execution_file }}
          RESULT_SONNET: ${{ steps.claude_sonnet.outputs.result }}
          RESULT_OPUS: ${{ steps.claude_opus.outputs.result }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = Number('${{ steps.decide.outputs.pr }}');

            // avoid duplicates when track_progress updated an existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, per_page: 50
            });
            if (comments.some(c =>
              /Overall Risk:|Top Findings:|Suggested Tests|Quick Refactors/i.test(c.body || '') &&
              c.user?.type === 'Bot'
            )) {
              core.info('Review comment already exists; skipping fallback.');
              process.exit(0);
            }

            let body = (process.env.RESULT_SONNET || process.env.RESULT_OPUS || '').trim();
            const execFile = process.env.EXEC_FILE_SONNET || process.env.EXEC_FILE_OPUS;
            if (!body && execFile && fs.existsSync(execFile)) {
              try {
                const data = JSON.parse(fs.readFileSync(execFile, 'utf8'));
                if (typeof data.result === 'string' && data.result.trim()) body = data.result.trim();
                else if (Array.isArray(data.turns)) {
                  for (let i = data.turns.length - 1; i >= 0; i--) {
                    const parts = (data.turns[i]?.message?.content || []).filter(x => x.type === 'text').map(x => x.text);
                    const text = parts.join('\n').trim();
                    if (text) { body = text; break; }
                  }
                }
              } catch {}
            }
            if (!body) body = '_Claude produced a review, but no formatted output was found. See logs._';

            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body
            });
            core.info('Posted fallback review comment.');

      # Remove claude label after review completes to prevent auto re-runs on subsequent pushes
      - name: Remove claude label (prevents auto re-run)
        if: always() && steps.decide.outputs.should_run == 'true' && steps.decide.outputs.internal == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.decide.outputs.pr }}');
            const mode = '${{ steps.decide.outputs.mode }}';
            const labelToRemove = mode === 'ultra' ? 'claude:ultra' : 'claude:review';

            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: labelToRemove
              });
              core.info(`Removed ${labelToRemove} label to prevent auto re-runs on future pushes.`);
            } catch (e) {
              if (e.status === 404) {
                core.info(`Label ${labelToRemove} was already removed.`);
              } else {
                core.warning(`Failed to remove label: ${e.message}`);
              }
            }
